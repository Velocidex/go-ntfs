
package parser

// Autogenerated code from ntfs_profile.json. Do not edit.

import (
    "encoding/binary"
    "fmt"
    "bytes"
    "io"
    "sort"
    "strings"
    "unicode/utf16"
    "unicode/utf8"
)

var (
   // Depending on autogenerated code we may use this. Add a reference
   // to shut the compiler up.
   _ = bytes.MinRead
   _ = fmt.Sprintf
   _ = utf16.Decode
   _ = binary.LittleEndian
   _ = utf8.RuneError
   _ = sort.Strings
   _ = strings.Join
)

type NTFSProfile struct {
    Off_ATTRIBUTE_LIST_ENTRY_Attribute_id int64
    Off_ATTRIBUTE_LIST_ENTRY_Length int64
    Off_ATTRIBUTE_LIST_ENTRY_MftReference int64
    Off_ATTRIBUTE_LIST_ENTRY_Name_length int64
    Off_ATTRIBUTE_LIST_ENTRY_Offset_to_name int64
    Off_ATTRIBUTE_LIST_ENTRY_Starting_vcn int64
    Off_ATTRIBUTE_LIST_ENTRY_Type int64
    Off_FILE_NAME_Allocated_size int64
    Off_FILE_NAME_Created int64
    Off_FILE_NAME_File_accessed int64
    Off_FILE_NAME_File_modified int64
    Off_FILE_NAME_FilenameSize int64
    Off_FILE_NAME_Flags int64
    Off_FILE_NAME_MftReference int64
    Off_FILE_NAME_Mft_modified int64
    Off_FILE_NAME_Reparse_value int64
    Off_FILE_NAME_Seq_num int64
    Off_FILE_NAME__length_of_name int64
    Off_FILE_NAME_name int64
    Off_FILE_NAME_name_type int64
    Off_INDEX_NODE_HEADER_Offset_to_end_index_entry int64
    Off_INDEX_NODE_HEADER_Offset_to_index_entry int64
    Off_INDEX_NODE_HEADER_SizeOfEntriesAlloc int64
    Off_INDEX_RECORD_ENTRY_File int64
    Off_INDEX_RECORD_ENTRY_FilenameOffset int64
    Off_INDEX_RECORD_ENTRY_Flags int64
    Off_INDEX_RECORD_ENTRY_MftReference int64
    Off_INDEX_RECORD_ENTRY_Seq_num int64
    Off_INDEX_RECORD_ENTRY_SizeOfIndexEntry int64
    Off_INDEX_ROOT_Collation_rule int64
    Off_INDEX_ROOT_Idx_size_c int64
    Off_INDEX_ROOT_Idxalloc_size_b int64
    Off_INDEX_ROOT_Node int64
    Off_INDEX_ROOT_Type int64
    Off_MFT_ENTRY_Attribute_offset int64
    Off_MFT_ENTRY_Base_record_reference int64
    Off_MFT_ENTRY_Fixup_count int64
    Off_MFT_ENTRY_Fixup_offset int64
    Off_MFT_ENTRY_Flags int64
    Off_MFT_ENTRY_Link_count int64
    Off_MFT_ENTRY_Logfile_sequence_number int64
    Off_MFT_ENTRY_Magic int64
    Off_MFT_ENTRY_Mft_entry_allocated int64
    Off_MFT_ENTRY_Mft_entry_size int64
    Off_MFT_ENTRY_Next_attribute_id int64
    Off_MFT_ENTRY_Record_number int64
    Off_MFT_ENTRY_Sequence_value int64
    Off_NTFS_ATTRIBUTE_Actual_size int64
    Off_NTFS_ATTRIBUTE_Allocated_size int64
    Off_NTFS_ATTRIBUTE_Attribute_id int64
    Off_NTFS_ATTRIBUTE_Compression_unit_size int64
    Off_NTFS_ATTRIBUTE_Content_offset int64
    Off_NTFS_ATTRIBUTE_Content_size int64
    Off_NTFS_ATTRIBUTE_Flags int64
    Off_NTFS_ATTRIBUTE_Initialized_size int64
    Off_NTFS_ATTRIBUTE_Length int64
    Off_NTFS_ATTRIBUTE_Resident int64
    Off_NTFS_ATTRIBUTE_Runlist_offset int64
    Off_NTFS_ATTRIBUTE_Runlist_vcn_end int64
    Off_NTFS_ATTRIBUTE_Runlist_vcn_start int64
    Off_NTFS_ATTRIBUTE_Type int64
    Off_NTFS_ATTRIBUTE_name_length int64
    Off_NTFS_ATTRIBUTE_name_offset int64
    Off_NTFS_BOOT_SECTOR_Index_record_size int64
    Off_NTFS_BOOT_SECTOR_Magic int64
    Off_NTFS_BOOT_SECTOR_Oemname int64
    Off_NTFS_BOOT_SECTOR_Sector_size int64
    Off_NTFS_BOOT_SECTOR_Serial int64
    Off_NTFS_BOOT_SECTOR__cluster_size int64
    Off_NTFS_BOOT_SECTOR__mft_cluster int64
    Off_NTFS_BOOT_SECTOR__mft_record_size int64
    Off_NTFS_BOOT_SECTOR__mirror_mft_cluster int64
    Off_NTFS_BOOT_SECTOR__volume_size int64
    Off_NTFS_RESIDENT_ATTRIBUTE_Attribute_id int64
    Off_NTFS_RESIDENT_ATTRIBUTE_Length int64
    Off_NTFS_RESIDENT_ATTRIBUTE_Name_length int64
    Off_NTFS_RESIDENT_ATTRIBUTE_Name_offset int64
    Off_NTFS_RESIDENT_ATTRIBUTE_Resident int64
    Off_NTFS_RESIDENT_ATTRIBUTE_Type int64
    Off_NTFS_RESIDENT_ATTRIBUTE_content_offset int64
    Off_NTFS_RESIDENT_ATTRIBUTE_content_size int64
    Off_STANDARD_INDEX_HEADER_Fixup_count int64
    Off_STANDARD_INDEX_HEADER_Fixup_offset int64
    Off_STANDARD_INDEX_HEADER_LogFileSeqNum int64
    Off_STANDARD_INDEX_HEADER_MagicNumber int64
    Off_STANDARD_INDEX_HEADER_Node int64
    Off_STANDARD_INDEX_HEADER_VcnOfINDX int64
    Off_STANDARD_INFORMATION_Class_id int64
    Off_STANDARD_INFORMATION_Create_time int64
    Off_STANDARD_INFORMATION_File_accessed_time int64
    Off_STANDARD_INFORMATION_File_altered_time int64
    Off_STANDARD_INFORMATION_Flags int64
    Off_STANDARD_INFORMATION_Max_versions int64
    Off_STANDARD_INFORMATION_Mft_altered_time int64
    Off_STANDARD_INFORMATION_Owner_id int64
    Off_STANDARD_INFORMATION_Quota int64
    Off_STANDARD_INFORMATION_Sid int64
    Off_STANDARD_INFORMATION_Usn int64
    Off_STANDARD_INFORMATION_Version int64
}

func NewNTFSProfile() *NTFSProfile {
    // Specific offsets can be tweaked to cater for slight version mismatches.
    self := &NTFSProfile{24,4,16,6,7,8,0,40,8,32,16,48,56,0,24,60,6,64,66,65,4,0,8,16,10,12,0,6,8,4,12,8,16,0,20,32,6,4,22,18,8,0,28,24,40,44,16,48,40,14,34,20,16,12,56,4,8,32,24,16,0,9,10,68,510,3,11,72,13,48,64,56,40,14,4,9,10,8,0,20,16,6,4,8,0,24,16,44,0,24,8,32,36,16,48,56,52,64,40}
    return self
}

func (self *NTFSProfile) ATTRIBUTE_LIST_ENTRY(reader io.ReaderAt, offset int64) *ATTRIBUTE_LIST_ENTRY {
    return &ATTRIBUTE_LIST_ENTRY{Reader: reader, Offset: offset, Profile: self}
}

func (self *NTFSProfile) FILE_NAME(reader io.ReaderAt, offset int64) *FILE_NAME {
    return &FILE_NAME{Reader: reader, Offset: offset, Profile: self}
}

func (self *NTFSProfile) INDEX_NODE_HEADER(reader io.ReaderAt, offset int64) *INDEX_NODE_HEADER {
    return &INDEX_NODE_HEADER{Reader: reader, Offset: offset, Profile: self}
}

func (self *NTFSProfile) INDEX_RECORD_ENTRY(reader io.ReaderAt, offset int64) *INDEX_RECORD_ENTRY {
    return &INDEX_RECORD_ENTRY{Reader: reader, Offset: offset, Profile: self}
}

func (self *NTFSProfile) INDEX_ROOT(reader io.ReaderAt, offset int64) *INDEX_ROOT {
    return &INDEX_ROOT{Reader: reader, Offset: offset, Profile: self}
}

func (self *NTFSProfile) MFT_ENTRY(reader io.ReaderAt, offset int64) *MFT_ENTRY {
    return &MFT_ENTRY{Reader: reader, Offset: offset, Profile: self}
}

func (self *NTFSProfile) NTFS_ATTRIBUTE(reader io.ReaderAt, offset int64) *NTFS_ATTRIBUTE {
    return &NTFS_ATTRIBUTE{Reader: reader, Offset: offset, Profile: self}
}

func (self *NTFSProfile) NTFS_BOOT_SECTOR(reader io.ReaderAt, offset int64) *NTFS_BOOT_SECTOR {
    return &NTFS_BOOT_SECTOR{Reader: reader, Offset: offset, Profile: self}
}

func (self *NTFSProfile) NTFS_RESIDENT_ATTRIBUTE(reader io.ReaderAt, offset int64) *NTFS_RESIDENT_ATTRIBUTE {
    return &NTFS_RESIDENT_ATTRIBUTE{Reader: reader, Offset: offset, Profile: self}
}

func (self *NTFSProfile) STANDARD_INDEX_HEADER(reader io.ReaderAt, offset int64) *STANDARD_INDEX_HEADER {
    return &STANDARD_INDEX_HEADER{Reader: reader, Offset: offset, Profile: self}
}

func (self *NTFSProfile) STANDARD_INFORMATION(reader io.ReaderAt, offset int64) *STANDARD_INFORMATION {
    return &STANDARD_INFORMATION{Reader: reader, Offset: offset, Profile: self}
}


type ATTRIBUTE_LIST_ENTRY struct {
    Reader io.ReaderAt
    Offset int64
    Profile *NTFSProfile
}

func (self *ATTRIBUTE_LIST_ENTRY) Size() int {
    return 0
}

func (self *ATTRIBUTE_LIST_ENTRY) Attribute_id() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_ATTRIBUTE_LIST_ENTRY_Attribute_id + self.Offset)
}

func (self *ATTRIBUTE_LIST_ENTRY) Length() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_ATTRIBUTE_LIST_ENTRY_Length + self.Offset)
}

func (self *ATTRIBUTE_LIST_ENTRY) MftReference() uint64 {
   value := ParseUint64(self.Reader, self.Profile.Off_ATTRIBUTE_LIST_ENTRY_MftReference + self.Offset)
   return (uint64(value) & 0xffffffffffff) >> 0x0
}

func (self *ATTRIBUTE_LIST_ENTRY) Name_length() byte {
   return ParseUint8(self.Reader, self.Profile.Off_ATTRIBUTE_LIST_ENTRY_Name_length + self.Offset)
}

func (self *ATTRIBUTE_LIST_ENTRY) Offset_to_name() byte {
   return ParseUint8(self.Reader, self.Profile.Off_ATTRIBUTE_LIST_ENTRY_Offset_to_name + self.Offset)
}

func (self *ATTRIBUTE_LIST_ENTRY) Starting_vcn() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_ATTRIBUTE_LIST_ENTRY_Starting_vcn + self.Offset)
}

func (self *ATTRIBUTE_LIST_ENTRY) Type() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_ATTRIBUTE_LIST_ENTRY_Type + self.Offset)
}
func (self *ATTRIBUTE_LIST_ENTRY) DebugString() string {
    result := fmt.Sprintf("struct ATTRIBUTE_LIST_ENTRY @ %#x:\n", self.Offset)
    result += fmt.Sprintf("Attribute_id: %#0x\n", self.Attribute_id())
    result += fmt.Sprintf("Length: %#0x\n", self.Length())
    result += fmt.Sprintf("MftReference: %#0x\n", self.MftReference())
    result += fmt.Sprintf("Name_length: %#0x\n", self.Name_length())
    result += fmt.Sprintf("Offset_to_name: %#0x\n", self.Offset_to_name())
    result += fmt.Sprintf("Starting_vcn: %#0x\n", self.Starting_vcn())
    result += fmt.Sprintf("Type: %#0x\n", self.Type())
    return result
}

type FILE_NAME struct {
    Reader io.ReaderAt
    Offset int64
    Profile *NTFSProfile
}

func (self *FILE_NAME) Size() int {
    return 66
}

func (self *FILE_NAME) Allocated_size() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_FILE_NAME_Allocated_size + self.Offset)
}

func (self *FILE_NAME) Created() *WinFileTime {
    return self.Profile.WinFileTime(self.Reader, self.Profile.Off_FILE_NAME_Created + self.Offset)
}

func (self *FILE_NAME) File_accessed() *WinFileTime {
    return self.Profile.WinFileTime(self.Reader, self.Profile.Off_FILE_NAME_File_accessed + self.Offset)
}

func (self *FILE_NAME) File_modified() *WinFileTime {
    return self.Profile.WinFileTime(self.Reader, self.Profile.Off_FILE_NAME_File_modified + self.Offset)
}

func (self *FILE_NAME) FilenameSize() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_FILE_NAME_FilenameSize + self.Offset)
}

func (self *FILE_NAME) Flags() *Flags {
   value := ParseUint32(self.Reader, self.Profile.Off_FILE_NAME_Flags + self.Offset)
   names := make(map[string]bool)


   if value & 1 != 0 {
      names["READ_ONLY"] = true
   }

   if value & 2 != 0 {
      names["HIDDEN"] = true
   }

   if value & 4 != 0 {
      names["SYSTEM"] = true
   }

   if value & 2048 != 0 {
      names["COMPRESSED"] = true
   }

   if value & 4096 != 0 {
      names["OFFLINE"] = true
   }

   if value & 8192 != 0 {
      names["NOT_INDEXED"] = true
   }

   if value & 32 != 0 {
      names["ARCHIVE"] = true
   }

   if value & 64 != 0 {
      names["DEVICE"] = true
   }

   if value & 128 != 0 {
      names["NORMAL"] = true
   }

   if value & 256 != 0 {
      names["TEMPORARY"] = true
   }

   if value & 512 != 0 {
      names["SPARSE"] = true
   }

   if value & 1024 != 0 {
      names["REPARSE_POINT"] = true
   }

   if value & 16384 != 0 {
      names["ENCRYPTED"] = true
   }

   return &Flags{Value: uint64(value), Names: names}
}


func (self *FILE_NAME) MftReference() uint64 {
   value := ParseUint64(self.Reader, self.Profile.Off_FILE_NAME_MftReference + self.Offset)
   return (uint64(value) & 0xffffffffffff) >> 0x0
}

func (self *FILE_NAME) Mft_modified() *WinFileTime {
    return self.Profile.WinFileTime(self.Reader, self.Profile.Off_FILE_NAME_Mft_modified + self.Offset)
}

func (self *FILE_NAME) Reparse_value() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_FILE_NAME_Reparse_value + self.Offset)
}

func (self *FILE_NAME) Seq_num() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_FILE_NAME_Seq_num + self.Offset)
}

func (self *FILE_NAME) _length_of_name() byte {
   return ParseUint8(self.Reader, self.Profile.Off_FILE_NAME__length_of_name + self.Offset)
}


func (self *FILE_NAME) name() string {
  return ParseTerminatedUTF16String(self.Reader, self.Profile.Off_FILE_NAME_name + self.Offset)
}

func (self *FILE_NAME) name_type() *Enumeration {
   value := ParseUint8(self.Reader, self.Profile.Off_FILE_NAME_name_type + self.Offset)
   name := "Unknown"
   switch value {

      case 0:
         name = "POSIX"

      case 1:
         name = "Win32"

      case 2:
         name = "DOS"

      case 3:
         name = "DOS+Win32"
}
   return &Enumeration{Value: uint64(value), Name: name}
}

func (self *FILE_NAME) DebugString() string {
    result := fmt.Sprintf("struct FILE_NAME @ %#x:\n", self.Offset)
    result += fmt.Sprintf("Allocated_size: %#0x\n", self.Allocated_size())
    result += fmt.Sprintf("Created: {\n%v}\n", self.Created().DebugString())
    result += fmt.Sprintf("File_accessed: {\n%v}\n", self.File_accessed().DebugString())
    result += fmt.Sprintf("File_modified: {\n%v}\n", self.File_modified().DebugString())
    result += fmt.Sprintf("FilenameSize: %#0x\n", self.FilenameSize())
    result += fmt.Sprintf("Flags: %v\n", self.Flags().DebugString())
    result += fmt.Sprintf("MftReference: %#0x\n", self.MftReference())
    result += fmt.Sprintf("Mft_modified: {\n%v}\n", self.Mft_modified().DebugString())
    result += fmt.Sprintf("Reparse_value: %#0x\n", self.Reparse_value())
    result += fmt.Sprintf("Seq_num: %#0x\n", self.Seq_num())
    result += fmt.Sprintf("_length_of_name: %#0x\n", self._length_of_name())
    result += fmt.Sprintf("name: %v\n", string(self.name()))
    result += fmt.Sprintf("name_type: %v\n", self.name_type().DebugString())
    return result
}

type INDEX_NODE_HEADER struct {
    Reader io.ReaderAt
    Offset int64
    Profile *NTFSProfile
}

func (self *INDEX_NODE_HEADER) Size() int {
    return 16
}

func (self *INDEX_NODE_HEADER) Offset_to_end_index_entry() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_INDEX_NODE_HEADER_Offset_to_end_index_entry + self.Offset)
}

func (self *INDEX_NODE_HEADER) Offset_to_index_entry() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_INDEX_NODE_HEADER_Offset_to_index_entry + self.Offset)
}

func (self *INDEX_NODE_HEADER) SizeOfEntriesAlloc() int32 {
   return ParseInt32(self.Reader, self.Profile.Off_INDEX_NODE_HEADER_SizeOfEntriesAlloc + self.Offset)
}
func (self *INDEX_NODE_HEADER) DebugString() string {
    result := fmt.Sprintf("struct INDEX_NODE_HEADER @ %#x:\n", self.Offset)
    result += fmt.Sprintf("Offset_to_end_index_entry: %#0x\n", self.Offset_to_end_index_entry())
    result += fmt.Sprintf("Offset_to_index_entry: %#0x\n", self.Offset_to_index_entry())
    result += fmt.Sprintf("SizeOfEntriesAlloc: %#0x\n", self.SizeOfEntriesAlloc())
    return result
}

type INDEX_RECORD_ENTRY struct {
    Reader io.ReaderAt
    Offset int64
    Profile *NTFSProfile
}

func (self *INDEX_RECORD_ENTRY) Size() int {
    return 0
}

func (self *INDEX_RECORD_ENTRY) File() *FILE_NAME {
    return self.Profile.FILE_NAME(self.Reader, self.Profile.Off_INDEX_RECORD_ENTRY_File + self.Offset)
}

func (self *INDEX_RECORD_ENTRY) FilenameOffset() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_INDEX_RECORD_ENTRY_FilenameOffset + self.Offset)
}

func (self *INDEX_RECORD_ENTRY) Flags() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_INDEX_RECORD_ENTRY_Flags + self.Offset)
}

func (self *INDEX_RECORD_ENTRY) MftReference() uint64 {
   value := ParseUint64(self.Reader, self.Profile.Off_INDEX_RECORD_ENTRY_MftReference + self.Offset)
   return (uint64(value) & 0xffffffffffff) >> 0x0
}

func (self *INDEX_RECORD_ENTRY) Seq_num() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_INDEX_RECORD_ENTRY_Seq_num + self.Offset)
}

func (self *INDEX_RECORD_ENTRY) SizeOfIndexEntry() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_INDEX_RECORD_ENTRY_SizeOfIndexEntry + self.Offset)
}
func (self *INDEX_RECORD_ENTRY) DebugString() string {
    result := fmt.Sprintf("struct INDEX_RECORD_ENTRY @ %#x:\n", self.Offset)
    result += fmt.Sprintf("File: {\n%v}\n", self.File().DebugString())
    result += fmt.Sprintf("FilenameOffset: %#0x\n", self.FilenameOffset())
    result += fmt.Sprintf("Flags: %#0x\n", self.Flags())
    result += fmt.Sprintf("MftReference: %#0x\n", self.MftReference())
    result += fmt.Sprintf("Seq_num: %#0x\n", self.Seq_num())
    result += fmt.Sprintf("SizeOfIndexEntry: %#0x\n", self.SizeOfIndexEntry())
    return result
}

type INDEX_ROOT struct {
    Reader io.ReaderAt
    Offset int64
    Profile *NTFSProfile
}

func (self *INDEX_ROOT) Size() int {
    return 0
}

func (self *INDEX_ROOT) Collation_rule() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_INDEX_ROOT_Collation_rule + self.Offset)
}

func (self *INDEX_ROOT) Idx_size_c() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_INDEX_ROOT_Idx_size_c + self.Offset)
}

func (self *INDEX_ROOT) Idxalloc_size_b() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_INDEX_ROOT_Idxalloc_size_b + self.Offset)
}

func (self *INDEX_ROOT) Node() *INDEX_NODE_HEADER {
    return self.Profile.INDEX_NODE_HEADER(self.Reader, self.Profile.Off_INDEX_ROOT_Node + self.Offset)
}

func (self *INDEX_ROOT) Type() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_INDEX_ROOT_Type + self.Offset)
}
func (self *INDEX_ROOT) DebugString() string {
    result := fmt.Sprintf("struct INDEX_ROOT @ %#x:\n", self.Offset)
    result += fmt.Sprintf("Collation_rule: %#0x\n", self.Collation_rule())
    result += fmt.Sprintf("Idx_size_c: %#0x\n", self.Idx_size_c())
    result += fmt.Sprintf("Idxalloc_size_b: %#0x\n", self.Idxalloc_size_b())
    result += fmt.Sprintf("Node: {\n%v}\n", self.Node().DebugString())
    result += fmt.Sprintf("Type: %#0x\n", self.Type())
    return result
}

type MFT_ENTRY struct {
    Reader io.ReaderAt
    Offset int64
    Profile *NTFSProfile
}

func (self *MFT_ENTRY) Size() int {
    return 0
}

func (self *MFT_ENTRY) Attribute_offset() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_MFT_ENTRY_Attribute_offset + self.Offset)
}

func (self *MFT_ENTRY) Base_record_reference() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_MFT_ENTRY_Base_record_reference + self.Offset)
}

func (self *MFT_ENTRY) Fixup_count() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_MFT_ENTRY_Fixup_count + self.Offset)
}

func (self *MFT_ENTRY) Fixup_offset() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_MFT_ENTRY_Fixup_offset + self.Offset)
}

func (self *MFT_ENTRY) Flags() *Flags {
   value := ParseUint16(self.Reader, self.Profile.Off_MFT_ENTRY_Flags + self.Offset)
   names := make(map[string]bool)


   if value & (1 << 0) != 0 {
      names["ALLOCATED"] = true
   }

   if value & (1 << 1) != 0 {
      names["DIRECTORY"] = true
   }

   return &Flags{Value: uint64(value), Names: names}
}


func (self *MFT_ENTRY) Link_count() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_MFT_ENTRY_Link_count + self.Offset)
}

func (self *MFT_ENTRY) Logfile_sequence_number() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_MFT_ENTRY_Logfile_sequence_number + self.Offset)
}


func (self *MFT_ENTRY) Magic() *Signature {
  value := ParseSignature(self.Reader, self.Profile.Off_MFT_ENTRY_Magic + self.Offset, 4)
  return &Signature{value: value, signature: "FILE"}
}

func (self *MFT_ENTRY) Mft_entry_allocated() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_MFT_ENTRY_Mft_entry_allocated + self.Offset)
}

func (self *MFT_ENTRY) Mft_entry_size() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_MFT_ENTRY_Mft_entry_size + self.Offset)
}

func (self *MFT_ENTRY) Next_attribute_id() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_MFT_ENTRY_Next_attribute_id + self.Offset)
}

func (self *MFT_ENTRY) Record_number() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_MFT_ENTRY_Record_number + self.Offset)
}

func (self *MFT_ENTRY) Sequence_value() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_MFT_ENTRY_Sequence_value + self.Offset)
}
func (self *MFT_ENTRY) DebugString() string {
    result := fmt.Sprintf("struct MFT_ENTRY @ %#x:\n", self.Offset)
    result += fmt.Sprintf("Attribute_offset: %#0x\n", self.Attribute_offset())
    result += fmt.Sprintf("Base_record_reference: %#0x\n", self.Base_record_reference())
    result += fmt.Sprintf("Fixup_count: %#0x\n", self.Fixup_count())
    result += fmt.Sprintf("Fixup_offset: %#0x\n", self.Fixup_offset())
    result += fmt.Sprintf("Flags: %v\n", self.Flags().DebugString())
    result += fmt.Sprintf("Link_count: %#0x\n", self.Link_count())
    result += fmt.Sprintf("Logfile_sequence_number: %#0x\n", self.Logfile_sequence_number())
    result += fmt.Sprintf("Mft_entry_allocated: %#0x\n", self.Mft_entry_allocated())
    result += fmt.Sprintf("Mft_entry_size: %#0x\n", self.Mft_entry_size())
    result += fmt.Sprintf("Next_attribute_id: %#0x\n", self.Next_attribute_id())
    result += fmt.Sprintf("Record_number: %#0x\n", self.Record_number())
    result += fmt.Sprintf("Sequence_value: %#0x\n", self.Sequence_value())
    return result
}

type NTFS_ATTRIBUTE struct {
    Reader io.ReaderAt
    Offset int64
    Profile *NTFSProfile
}

func (self *NTFS_ATTRIBUTE) Size() int {
    return 0
}

func (self *NTFS_ATTRIBUTE) Actual_size() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Actual_size + self.Offset)
}

func (self *NTFS_ATTRIBUTE) Allocated_size() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Allocated_size + self.Offset)
}

func (self *NTFS_ATTRIBUTE) Attribute_id() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Attribute_id + self.Offset)
}

func (self *NTFS_ATTRIBUTE) Compression_unit_size() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Compression_unit_size + self.Offset)
}

func (self *NTFS_ATTRIBUTE) Content_offset() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Content_offset + self.Offset)
}

func (self *NTFS_ATTRIBUTE) Content_size() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Content_size + self.Offset)
}

func (self *NTFS_ATTRIBUTE) Flags() *Flags {
   value := ParseUint16(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Flags + self.Offset)
   names := make(map[string]bool)


   if value & (1 << 15) != 0 {
      names["SPARSE"] = true
   }

   if value & (1 << 0) != 0 {
      names["COMPRESSED"] = true
   }

   if value & (1 << 14) != 0 {
      names["ENCRYPTED"] = true
   }

   return &Flags{Value: uint64(value), Names: names}
}


func (self *NTFS_ATTRIBUTE) Initialized_size() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Initialized_size + self.Offset)
}

func (self *NTFS_ATTRIBUTE) Length() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Length + self.Offset)
}

func (self *NTFS_ATTRIBUTE) Resident() *Enumeration {
   value := ParseUint8(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Resident + self.Offset)
   name := "Unknown"
   switch value {

      case 0:
         name = "RESIDENT"

      case 1:
         name = "NON-RESIDENT"
}
   return &Enumeration{Value: uint64(value), Name: name}
}


func (self *NTFS_ATTRIBUTE) Runlist_offset() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Runlist_offset + self.Offset)
}

func (self *NTFS_ATTRIBUTE) Runlist_vcn_end() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Runlist_vcn_end + self.Offset)
}

func (self *NTFS_ATTRIBUTE) Runlist_vcn_start() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Runlist_vcn_start + self.Offset)
}

func (self *NTFS_ATTRIBUTE) Type() *Enumeration {
   value := ParseUint32(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_Type + self.Offset)
   name := "Unknown"
   switch value {

      case 16:
         name = "$STANDARD_INFORMATION"

      case 32:
         name = "$ATTRIBUTE_LIST"

      case 48:
         name = "$FILE_NAME"

      case 64:
         name = "$OBJECT_ID"

      case 80:
         name = "$SECURITY_DESCRIPTOR"

      case 96:
         name = "$VOLUME_NAME"

      case 112:
         name = "$VOLUME_INFORMATION"

      case 128:
         name = "$DATA"

      case 144:
         name = "$INDEX_ROOT"

      case 160:
         name = "$INDEX_ALLOCATION"

      case 176:
         name = "$BITMAP"

      case 192:
         name = "$REPARSE_POINT"

      case 208:
         name = "$EA_INFORMATION"

      case 224:
         name = "$EA"

      case 256:
         name = "$LOGGED_UTILITY_STREAM"
}
   return &Enumeration{Value: uint64(value), Name: name}
}


func (self *NTFS_ATTRIBUTE) name_length() byte {
   return ParseUint8(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_name_length + self.Offset)
}

func (self *NTFS_ATTRIBUTE) name_offset() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_NTFS_ATTRIBUTE_name_offset + self.Offset)
}
func (self *NTFS_ATTRIBUTE) DebugString() string {
    result := fmt.Sprintf("struct NTFS_ATTRIBUTE @ %#x:\n", self.Offset)
    result += fmt.Sprintf("Actual_size: %#0x\n", self.Actual_size())
    result += fmt.Sprintf("Allocated_size: %#0x\n", self.Allocated_size())
    result += fmt.Sprintf("Attribute_id: %#0x\n", self.Attribute_id())
    result += fmt.Sprintf("Compression_unit_size: %#0x\n", self.Compression_unit_size())
    result += fmt.Sprintf("Content_offset: %#0x\n", self.Content_offset())
    result += fmt.Sprintf("Content_size: %#0x\n", self.Content_size())
    result += fmt.Sprintf("Flags: %v\n", self.Flags().DebugString())
    result += fmt.Sprintf("Initialized_size: %#0x\n", self.Initialized_size())
    result += fmt.Sprintf("Length: %#0x\n", self.Length())
    result += fmt.Sprintf("Resident: %v\n", self.Resident().DebugString())
    result += fmt.Sprintf("Runlist_offset: %#0x\n", self.Runlist_offset())
    result += fmt.Sprintf("Runlist_vcn_end: %#0x\n", self.Runlist_vcn_end())
    result += fmt.Sprintf("Runlist_vcn_start: %#0x\n", self.Runlist_vcn_start())
    result += fmt.Sprintf("Type: %v\n", self.Type().DebugString())
    result += fmt.Sprintf("name_length: %#0x\n", self.name_length())
    result += fmt.Sprintf("name_offset: %#0x\n", self.name_offset())
    return result
}

type NTFS_BOOT_SECTOR struct {
    Reader io.ReaderAt
    Offset int64
    Profile *NTFSProfile
}

func (self *NTFS_BOOT_SECTOR) Size() int {
    return 512
}

func (self *NTFS_BOOT_SECTOR) Index_record_size() byte {
   return ParseUint8(self.Reader, self.Profile.Off_NTFS_BOOT_SECTOR_Index_record_size + self.Offset)
}

func (self *NTFS_BOOT_SECTOR) Magic() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_NTFS_BOOT_SECTOR_Magic + self.Offset)
}


func (self *NTFS_BOOT_SECTOR) Oemname() string {
  return ParseString(self.Reader, self.Profile.Off_NTFS_BOOT_SECTOR_Oemname + self.Offset, 8)
}

func (self *NTFS_BOOT_SECTOR) Sector_size() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_NTFS_BOOT_SECTOR_Sector_size + self.Offset)
}


func (self *NTFS_BOOT_SECTOR) Serial() string {
  return ParseString(self.Reader, self.Profile.Off_NTFS_BOOT_SECTOR_Serial + self.Offset, 8)
}

func (self *NTFS_BOOT_SECTOR) _cluster_size() byte {
   return ParseUint8(self.Reader, self.Profile.Off_NTFS_BOOT_SECTOR__cluster_size + self.Offset)
}

func (self *NTFS_BOOT_SECTOR) _mft_cluster() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_NTFS_BOOT_SECTOR__mft_cluster + self.Offset)
}

func (self *NTFS_BOOT_SECTOR) _mft_record_size() int8 {
   return ParseInt8(self.Reader, self.Profile.Off_NTFS_BOOT_SECTOR__mft_record_size + self.Offset)
}

func (self *NTFS_BOOT_SECTOR) _mirror_mft_cluster() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_NTFS_BOOT_SECTOR__mirror_mft_cluster + self.Offset)
}

func (self *NTFS_BOOT_SECTOR) _volume_size() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_NTFS_BOOT_SECTOR__volume_size + self.Offset)
}
func (self *NTFS_BOOT_SECTOR) DebugString() string {
    result := fmt.Sprintf("struct NTFS_BOOT_SECTOR @ %#x:\n", self.Offset)
    result += fmt.Sprintf("Index_record_size: %#0x\n", self.Index_record_size())
    result += fmt.Sprintf("Magic: %#0x\n", self.Magic())
    result += fmt.Sprintf("Oemname: %v\n", string(self.Oemname()))
    result += fmt.Sprintf("Sector_size: %#0x\n", self.Sector_size())
    result += fmt.Sprintf("Serial: %v\n", string(self.Serial()))
    result += fmt.Sprintf("_cluster_size: %#0x\n", self._cluster_size())
    result += fmt.Sprintf("_mft_cluster: %#0x\n", self._mft_cluster())
    result += fmt.Sprintf("_mft_record_size: %#0x\n", self._mft_record_size())
    result += fmt.Sprintf("_mirror_mft_cluster: %#0x\n", self._mirror_mft_cluster())
    result += fmt.Sprintf("_volume_size: %#0x\n", self._volume_size())
    return result
}

type NTFS_RESIDENT_ATTRIBUTE struct {
    Reader io.ReaderAt
    Offset int64
    Profile *NTFSProfile
}

func (self *NTFS_RESIDENT_ATTRIBUTE) Size() int {
    return 0
}

func (self *NTFS_RESIDENT_ATTRIBUTE) Attribute_id() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_NTFS_RESIDENT_ATTRIBUTE_Attribute_id + self.Offset)
}

func (self *NTFS_RESIDENT_ATTRIBUTE) Length() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_NTFS_RESIDENT_ATTRIBUTE_Length + self.Offset)
}

func (self *NTFS_RESIDENT_ATTRIBUTE) Name_length() byte {
   return ParseUint8(self.Reader, self.Profile.Off_NTFS_RESIDENT_ATTRIBUTE_Name_length + self.Offset)
}

func (self *NTFS_RESIDENT_ATTRIBUTE) Name_offset() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_NTFS_RESIDENT_ATTRIBUTE_Name_offset + self.Offset)
}

func (self *NTFS_RESIDENT_ATTRIBUTE) Resident() *Enumeration {
   value := ParseUint8(self.Reader, self.Profile.Off_NTFS_RESIDENT_ATTRIBUTE_Resident + self.Offset)
   name := "Unknown"
   switch value {

      case 0:
         name = "RESIDENT"

      case 1:
         name = "NON-RESIDENT"
}
   return &Enumeration{Value: uint64(value), Name: name}
}


func (self *NTFS_RESIDENT_ATTRIBUTE) Type() *Enumeration {
   value := ParseUint32(self.Reader, self.Profile.Off_NTFS_RESIDENT_ATTRIBUTE_Type + self.Offset)
   name := "Unknown"
   switch value {

      case 16:
         name = "$STANDARD_INFORMATION"

      case 32:
         name = "$ATTRIBUTE_LIST"

      case 48:
         name = "$FILE_NAME"

      case 64:
         name = "$OBJECT_ID"

      case 80:
         name = "$SECURITY_DESCRIPTOR"

      case 96:
         name = "$VOLUME_NAME"

      case 112:
         name = "$VOLUME_INFORMATION"

      case 128:
         name = "$DATA"

      case 144:
         name = "$INDEX_ROOT"

      case 160:
         name = "$INDEX_ALLOCATION"

      case 176:
         name = "$BITMAP"

      case 192:
         name = "$REPARSE_POINT"

      case 256:
         name = "$LOGGED_UTILITY_STREAM"
}
   return &Enumeration{Value: uint64(value), Name: name}
}


func (self *NTFS_RESIDENT_ATTRIBUTE) content_offset() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_NTFS_RESIDENT_ATTRIBUTE_content_offset + self.Offset)
}

func (self *NTFS_RESIDENT_ATTRIBUTE) content_size() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_NTFS_RESIDENT_ATTRIBUTE_content_size + self.Offset)
}
func (self *NTFS_RESIDENT_ATTRIBUTE) DebugString() string {
    result := fmt.Sprintf("struct NTFS_RESIDENT_ATTRIBUTE @ %#x:\n", self.Offset)
    result += fmt.Sprintf("Attribute_id: %#0x\n", self.Attribute_id())
    result += fmt.Sprintf("Length: %#0x\n", self.Length())
    result += fmt.Sprintf("Name_length: %#0x\n", self.Name_length())
    result += fmt.Sprintf("Name_offset: %#0x\n", self.Name_offset())
    result += fmt.Sprintf("Resident: %v\n", self.Resident().DebugString())
    result += fmt.Sprintf("Type: %v\n", self.Type().DebugString())
    result += fmt.Sprintf("content_offset: %#0x\n", self.content_offset())
    result += fmt.Sprintf("content_size: %#0x\n", self.content_size())
    return result
}

type STANDARD_INDEX_HEADER struct {
    Reader io.ReaderAt
    Offset int64
    Profile *NTFSProfile
}

func (self *STANDARD_INDEX_HEADER) Size() int {
    return 42
}

func (self *STANDARD_INDEX_HEADER) Fixup_count() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_STANDARD_INDEX_HEADER_Fixup_count + self.Offset)
}

func (self *STANDARD_INDEX_HEADER) Fixup_offset() uint16 {
   return ParseUint16(self.Reader, self.Profile.Off_STANDARD_INDEX_HEADER_Fixup_offset + self.Offset)
}

func (self *STANDARD_INDEX_HEADER) LogFileSeqNum() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_STANDARD_INDEX_HEADER_LogFileSeqNum + self.Offset)
}


func (self *STANDARD_INDEX_HEADER) MagicNumber() *Signature {
  value := ParseSignature(self.Reader, self.Profile.Off_STANDARD_INDEX_HEADER_MagicNumber + self.Offset, 4)
  return &Signature{value: value, signature: "INDX"}
}

func (self *STANDARD_INDEX_HEADER) Node() *INDEX_NODE_HEADER {
    return self.Profile.INDEX_NODE_HEADER(self.Reader, self.Profile.Off_STANDARD_INDEX_HEADER_Node + self.Offset)
}

func (self *STANDARD_INDEX_HEADER) VcnOfINDX() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_STANDARD_INDEX_HEADER_VcnOfINDX + self.Offset)
}
func (self *STANDARD_INDEX_HEADER) DebugString() string {
    result := fmt.Sprintf("struct STANDARD_INDEX_HEADER @ %#x:\n", self.Offset)
    result += fmt.Sprintf("Fixup_count: %#0x\n", self.Fixup_count())
    result += fmt.Sprintf("Fixup_offset: %#0x\n", self.Fixup_offset())
    result += fmt.Sprintf("LogFileSeqNum: %#0x\n", self.LogFileSeqNum())
    result += fmt.Sprintf("Node: {\n%v}\n", self.Node().DebugString())
    result += fmt.Sprintf("VcnOfINDX: %#0x\n", self.VcnOfINDX())
    return result
}

type STANDARD_INFORMATION struct {
    Reader io.ReaderAt
    Offset int64
    Profile *NTFSProfile
}

func (self *STANDARD_INFORMATION) Size() int {
    return 0
}

func (self *STANDARD_INFORMATION) Class_id() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_STANDARD_INFORMATION_Class_id + self.Offset)
}

func (self *STANDARD_INFORMATION) Create_time() *WinFileTime {
    return self.Profile.WinFileTime(self.Reader, self.Profile.Off_STANDARD_INFORMATION_Create_time + self.Offset)
}

func (self *STANDARD_INFORMATION) File_accessed_time() *WinFileTime {
    return self.Profile.WinFileTime(self.Reader, self.Profile.Off_STANDARD_INFORMATION_File_accessed_time + self.Offset)
}

func (self *STANDARD_INFORMATION) File_altered_time() *WinFileTime {
    return self.Profile.WinFileTime(self.Reader, self.Profile.Off_STANDARD_INFORMATION_File_altered_time + self.Offset)
}

func (self *STANDARD_INFORMATION) Flags() *Flags {
   value := ParseUint32(self.Reader, self.Profile.Off_STANDARD_INFORMATION_Flags + self.Offset)
   names := make(map[string]bool)


   if value & 32 != 0 {
      names["ARCHIVE"] = true
   }

   if value & 64 != 0 {
      names["DEVICE"] = true
   }

   if value & 128 != 0 {
      names["NORMAL"] = true
   }

   if value & 512 != 0 {
      names["SPARSE"] = true
   }

   if value & 8192 != 0 {
      names["NOT_INDEXED"] = true
   }

   if value & 16384 != 0 {
      names["ENCRYPTED"] = true
   }

   if value & 1 != 0 {
      names["READ_ONLY"] = true
   }

   if value & 2 != 0 {
      names["HIDDEN"] = true
   }

   if value & 4 != 0 {
      names["SYSTEM"] = true
   }

   if value & 256 != 0 {
      names["TEMPORARY"] = true
   }

   if value & 1024 != 0 {
      names["REPARSE_POINT"] = true
   }

   if value & 2048 != 0 {
      names["COMPRESSED"] = true
   }

   if value & 4096 != 0 {
      names["OFFLINE"] = true
   }

   return &Flags{Value: uint64(value), Names: names}
}


func (self *STANDARD_INFORMATION) Max_versions() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_STANDARD_INFORMATION_Max_versions + self.Offset)
}

func (self *STANDARD_INFORMATION) Mft_altered_time() *WinFileTime {
    return self.Profile.WinFileTime(self.Reader, self.Profile.Off_STANDARD_INFORMATION_Mft_altered_time + self.Offset)
}

func (self *STANDARD_INFORMATION) Owner_id() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_STANDARD_INFORMATION_Owner_id + self.Offset)
}

func (self *STANDARD_INFORMATION) Quota() uint64 {
    return ParseUint64(self.Reader, self.Profile.Off_STANDARD_INFORMATION_Quota + self.Offset)
}

func (self *STANDARD_INFORMATION) Sid() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_STANDARD_INFORMATION_Sid + self.Offset)
}

func (self *STANDARD_INFORMATION) Usn() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_STANDARD_INFORMATION_Usn + self.Offset)
}

func (self *STANDARD_INFORMATION) Version() uint32 {
   return ParseUint32(self.Reader, self.Profile.Off_STANDARD_INFORMATION_Version + self.Offset)
}
func (self *STANDARD_INFORMATION) DebugString() string {
    result := fmt.Sprintf("struct STANDARD_INFORMATION @ %#x:\n", self.Offset)
    result += fmt.Sprintf("Class_id: %#0x\n", self.Class_id())
    result += fmt.Sprintf("Create_time: {\n%v}\n", self.Create_time().DebugString())
    result += fmt.Sprintf("File_accessed_time: {\n%v}\n", self.File_accessed_time().DebugString())
    result += fmt.Sprintf("File_altered_time: {\n%v}\n", self.File_altered_time().DebugString())
    result += fmt.Sprintf("Flags: %v\n", self.Flags().DebugString())
    result += fmt.Sprintf("Max_versions: %#0x\n", self.Max_versions())
    result += fmt.Sprintf("Mft_altered_time: {\n%v}\n", self.Mft_altered_time().DebugString())
    result += fmt.Sprintf("Owner_id: %#0x\n", self.Owner_id())
    result += fmt.Sprintf("Quota: %#0x\n", self.Quota())
    result += fmt.Sprintf("Sid: %#0x\n", self.Sid())
    result += fmt.Sprintf("Usn: %#0x\n", self.Usn())
    result += fmt.Sprintf("Version: %#0x\n", self.Version())
    return result
}

type Enumeration struct {
    Value uint64
    Name  string
}

func (self Enumeration) DebugString() string {
    return fmt.Sprintf("%s (%d)", self.Name, self.Value)
}


type Flags struct {
    Value uint64
    Names  map[string]bool
}

func (self Flags) DebugString() string {
    names := []string{}
    for k, _ := range self.Names {
      names = append(names, k)
    }

    sort.Strings(names)

    return fmt.Sprintf("%d (%s)", self.Value, strings.Join(names, ","))
}

func (self Flags) IsSet(flag string) bool {
    result, _ := self.Names[flag]
    return result
}


func ParseInt32(reader io.ReaderAt, offset int64) int32 {
    data := make([]byte, 4)
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return int32(binary.LittleEndian.Uint32(data))
}

func ParseInt8(reader io.ReaderAt, offset int64) int8 {
    result := make([]byte, 1)
    _, err := reader.ReadAt(result, offset)
    if err != nil {
       return 0
    }
    return int8(result[0])
}

func ParseUint16(reader io.ReaderAt, offset int64) uint16 {
    data := make([]byte, 2)
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint16(data)
}

func ParseUint32(reader io.ReaderAt, offset int64) uint32 {
    data := make([]byte, 4)
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint32(data)
}

func ParseUint64(reader io.ReaderAt, offset int64) uint64 {
    data := make([]byte, 8)
    _, err := reader.ReadAt(data, offset)
    if err != nil {
       return 0
    }
    return binary.LittleEndian.Uint64(data)
}

func ParseUint8(reader io.ReaderAt, offset int64) byte {
    result := make([]byte, 1)
    _, err := reader.ReadAt(result, offset)
    if err != nil {
       return 0
    }
    return result[0]
}


type Signature struct {
    value, signature string
}

func (self Signature) IsValid() bool {
   return self.value == self.signature
}

func ParseSignature(reader io.ReaderAt, offset int64, length int64) string {
   data := make([]byte, length)
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
      return ""
   }
   return string(data[:n])
}


func ParseTerminatedString(reader io.ReaderAt, offset int64) string {
   data := make([]byte, 1024)
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
     return ""
   }
   idx := bytes.Index(data[:n], []byte{0})
   if idx < 0 {
      idx = n
   }
   return string(data[0:idx])
}

func ParseString(reader io.ReaderAt, offset int64, length int64) string {
   data := make([]byte, length)
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
      return ""
   }
   return string(data[:n])
}


func ParseTerminatedUTF16String(reader io.ReaderAt, offset int64) string {
   data := make([]byte, 1024)
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
     return ""
   }

   idx := bytes.Index(data[:n], []byte{0, 0})
   if idx < 0 {
      idx = n-1
   }
   return UTF16BytesToUTF8(data[0:idx+1], binary.LittleEndian)
}

func ParseUTF16String(reader io.ReaderAt, offset int64, length int64) string {
   data := make([]byte, length)
   n, err := reader.ReadAt(data, offset)
   if err != nil && err != io.EOF {
     return ""
   }
   return UTF16BytesToUTF8(data[:n], binary.LittleEndian)
}

func UTF16BytesToUTF8(b []byte, o binary.ByteOrder) string {
	if len(b) < 2 {
		return ""
	}

	if b[0] == 0xff && b[1] == 0xfe {
		o = binary.BigEndian
		b = b[2:]
	} else if b[0] == 0xfe && b[1] == 0xff {
		o = binary.LittleEndian
		b = b[2:]
	}

	utf := make([]uint16, (len(b)+(2-1))/2)

	for i := 0; i+(2-1) < len(b); i += 2 {
		utf[i/2] = o.Uint16(b[i:])
	}
	if len(b)/2 < len(utf) {
		utf[len(utf)-1] = utf8.RuneError
	}

	return string(utf16.Decode(utf))
}


